 /****************************************************************************
*
*   Copyright (c) 2012, BeiJing EFLAG Technology Co., LTD.
*   All rights reserved.
*
*   文件名称 ：stm32f2xx_it.c
*   摘 要    ： 
*
*   当前版本 ： 
*   作 者    ： EFLAG
*   完成日期 ： 
*
*   取代版本 ：
*   原作者   ： 
*   修改内容 ：
*   完成日期 ：2012.08.01 
*
******************************************************************************/

/*************头文件**********************************************************/
#include "stm32f2xx_it.h"
#include "stm32_eval.h"

/* 重定义 -------------------------------------------------------------------*/
/* 自定义 -------------------------------------------------------------------*/
/* 私有宏定义 ---------------------------------------------------------------*/
/* 私有变量 -----------------------------------------------------------------*/
extern __IO uint8_t PreemptionOccured;
extern __IO uint8_t PreemptionPriorityValue; 

/******************************************************************************/
/*            Cortex-M3 处理器异常处理程序                         */
/******************************************************************************/

/****************************************************************************
* 函数名: NMI_Handler()
* 功 能: 该函数可以处理屏敝中断异常
* 输 入: 无
* 输 出: 无
****************************************************************************/
void NMI_Handler(void)
{
}

/****************************************************************************
* 函数名: HardFault_Handler()
* 功 能: 该函数可以处理硬件异常
* 输 入: 无
* 输 出: 无
****************************************************************************/
void HardFault_Handler(void)
{
  /* 硬件异常发生时进入无限循环 */
  while (1)
  {
  }
}

/****************************************************************************
* 函数名: MemManage_Handler()
* 功 能: 该函数可以处理内存管理异常
* 输 入: 无
* 输 出: 无
****************************************************************************/
void MemManage_Handler(void)
{
  /* 内存管理异常发生时进入无限循环 */
  while (1)
  {
  }
}

/****************************************************************************
* 函数名: BusFault_Handler()
* 功 能: 该函数可以处理总线错误异常
* 输 入: 无
* 输 出: 无
****************************************************************************/
void BusFault_Handler(void)
{
  /* 总线错误异常发生时进入无限循环 */
  while (1)
  {
  }
}

/****************************************************************************
* 函数名: UsageFault_Handler()
* 功 能: 该函数可以处理非法使用异常
* 输 入: 无
* 输 出: 无
****************************************************************************/
void UsageFault_Handler(void)
{
  /* 非法使用异常发生时进入无限循环 */
  while (1)
  {
  }
}

/****************************************************************************
* 函数名: SVC_Handler()
* 功 能: 该函数可以处理不安全访问异常
* 输 入: 无
* 输 出: 无
****************************************************************************/
void SVC_Handler(void)
{
}

/****************************************************************************
* 函数名: DebugMon_Handler()
* 功 能: 该函数可以处理调试监视器异常
* 输 入: 无
* 输 出: 无
****************************************************************************/
void DebugMon_Handler(void)
{
}

/****************************************************************************
* 函数名: PendSV_Handler()
* 功 能: 该函数可以处理交换虚拟电路挂起异常
* 输 入: 无
* 输 出: 无
****************************************************************************/
void PendSV_Handler(void)
{
}

/****************************************************************************
* 函数名: SysTick_Handler()
* 功 能: 该函数可以处理系统时钟
* 输 入: 无
* 输 出: 无
****************************************************************************/
void SysTick_Handler(void)
{
  /* 如果WAKEUP_BUTTON_EXTI中断操作被系统时钟抢占(EXTI0_IRQHandler) */
  if(NVIC_GetActive(USER1_BUTTON_EXTI_IRQn) != 0)
  {
    PreemptionOccured = 1;
  }
}

/******************************************************************************/
/*                 STM32F2xx外围设备的中断处理程序                            */
/*  在这里添加外围中断处理程序                                                */
/*  可用的外围中断处理程序的操作名称请参阅启动文件startup_stm32f2xx.s         */
/******************************************************************************/

/****************************************************************************
* 函数名: EXTI0_IRQHandler()
* 功 能: 该函数可以处理外部线0中断请求
* 输 入: 无
* 输 出: 无
****************************************************************************/
void EXTI0_IRQHandler(void)
{
  /* 产生时钟异常 */
  SCB->ICSR |= 0x04000000;
  
  /* 清除WAKEUP_BUTTON_EXTI_LINE挂起位 */
  EXTI_ClearITPendingBit(USER2_BUTTON_EXTI_IRQn);
}

/****************************************************************************
* 函数名: EXTI15_10_IRQHandler()
* 功 能: 该函数可以处理外部行15 - 10中断请求
* 输 入: 无
* 输 出: 无
****************************************************************************/ 
void EXTI15_10_IRQHandler(void)
{
  NVIC_InitTypeDef NVIC_InitStructure;
  SCB->ICSR |= 0x04000000;
  if(EXTI_GetITStatus(USER1_BUTTON_EXTI_LINE) != RESET)
  {
    PreemptionPriorityValue = !PreemptionPriorityValue;
    PreemptionOccured = 0;

    /* 修改WAKEUP_BUTTON_EXTI_IRQn抢占中断优先级 */
    NVIC_InitStructure.NVIC_IRQChannel = USER2_BUTTON_EXTI_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = PreemptionPriorityValue;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStructure);
    
    /* 配置SysTick处理器优先级: 抢占优先级和子优先级 */
    NVIC_SetPriority(SysTick_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), !PreemptionPriorityValue, 0));    

    /* 清除WAKEUP_BUTTON_EXTI_LINE挂起位 */
    EXTI_ClearITPendingBit(USER1_BUTTON_EXTI_LINE);
  }
}

/****** (C) 版权2012北京亿旗创新科技发展有限公司 ******文档结束*************/
