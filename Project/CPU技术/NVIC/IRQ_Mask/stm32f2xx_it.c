 /****************************************************************************
*
*   Copyright (c) 2012, BeiJing EFLAG Technology Co., LTD.
*   All rights reserved.
*
*   文件名称 ：stm32f2xx_it.c
*   摘 要    ： 
*
*   当前版本 ： 
*   作 者    ： EFLAG
*   完成日期 ： 
*
*   取代版本 ：
*   原作者   ： 
*   修改内容 ：
*   完成日期 ：2012.08.01 
*
******************************************************************************/

/*************头文件**********************************************************/
#include "stm32f2xx_it.h"
#include "stm32_eval.h"

/* 重定义 -------------------------------------------------------------------*/
/* 自定义 -------------------------------------------------------------------*/
/* 私有宏定义 ---------------------------------------------------------------*/
/* 私有变量 -----------------------------------------------------------------*/
__IO uint32_t index = 0;

/******************************************************************************/
/*            Cortex-M3 处理器异常处理程序                         */
/******************************************************************************/

/****************************************************************************
* 函数名: NMI_Handler()
* 功 能: 该函数可以处理屏敝中断异常
* 输 入: 无
* 输 出: 无
****************************************************************************/
void NMI_Handler(void)
{
}

/****************************************************************************
* 函数名: HardFault_Handler()
* 功 能: 该函数可以处理硬件异常
* 输 入: 无
* 输 出: 无
****************************************************************************/
void HardFault_Handler(void)
{
  /* 硬件异常发生时进入无限循环 */
  while (1)
  {
  }
}

/****************************************************************************
* 函数名: MemManage_Handler()
* 功 能: 该函数可以处理内存管理异常
* 输 入: 无
* 输 出: 无
****************************************************************************/
void MemManage_Handler(void)
{
  /* 内存管理异常发生时进入无限循环 */
  while (1)
  {
  }
}

/****************************************************************************
* 函数名: BusFault_Handler()
* 功 能: 该函数可以处理总线错误异常
* 输 入: 无
* 输 出: 无
****************************************************************************/
void BusFault_Handler(void)
{
  /* 总线错误异常发生时进入无限循环 */
  while (1)
  {
  }
}

/****************************************************************************
* 函数名: UsageFault_Handler()
* 功 能: 该函数可以处理非法使用异常
* 输 入: 无
* 输 出: 无
****************************************************************************/
void UsageFault_Handler(void)
{
  /* 非法使用异常发生时进入无限循环 */
  while (1)
  {
  }
}

/****************************************************************************
* 函数名: SVC_Handler()
* 功 能: 该函数可以处理不安全访问异常
* 输 入: 无
* 输 出: 无
****************************************************************************/
void SVC_Handler(void)
{
}

/****************************************************************************
* 函数名: DebugMon_Handler()
* 功 能: 该函数可以处理调试监视器异常
* 输 入: 无
* 输 出: 无
****************************************************************************/
void DebugMon_Handler(void)
{
}

/****************************************************************************
* 函数名: PendSV_Handler()
* 功 能: 该函数可以处理交换虚拟电路挂起异常
* 输 入: 无
* 输 出: 无
****************************************************************************/
void PendSV_Handler(void)
{
}

/****************************************************************************
* 函数名: SysTick_Handler()
* 功 能: 该函数可以处理系统时钟
* 输 入: 无
* 输 出: 无
****************************************************************************/
void SysTick_Handler(void)
{
}

/******************************************************************************/
/*                 STM32F2xx外围设备的中断处理程序                            */
/*  在这里添加外围中断处理程序                                                */
/*  可用的外围中断处理程序的操作名称请参阅启动文件startup_stm32f2xx.s         */
/******************************************************************************/

/****************************************************************************
* 函数名: EXTI15_10_IRQHandler()
* 功 能: 该函数可以处理中断行15至10的中断请求
* 输 入: 无
* 输 出: 无
****************************************************************************/
void EXTI15_10_IRQHandler(void)
{
  if(EXTI_GetITStatus(USER1_BUTTON_EXTI_LINE ) != RESET)
  {
    if(index == 0)
    {
      /* 配置BASEPRI寄存器为0x40 (抢占优先级=1)，只有硬中断请求优先级别比1高的
	     优先级的才允许抢占，所以这会屏蔽掉TIM3和TIM4产生的硬中断请求 */
      __set_BASEPRI(0x40);
      index++;
    }
    else
    {
      /* 配置BASEPRI寄存器为0x00 (抢占优先级=0)，当BASEPRI寄存器被设置成0时, 
	  	 它对当前优先级没有影响。TIM2,TIM3和TIM4的产生受优先级寄存器NVIC控制 */
      __set_BASEPRI(0x00);
      index = 0;
    }

    /* 清除TAMPER按钮中断线挂起位 */
    EXTI_ClearITPendingBit(USER1_BUTTON_EXTI_LINE );  
  }
} 

/****************************************************************************
* 函数名: TIM2_IRQHandler()
* 功 能: 该函数可以处理TIM2全部中断请求
* 输 入: 无
* 输 出: 无
****************************************************************************/
void TIM2_IRQHandler(void)
{
  /* 清除TIM2更新中断 */
  TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
  
  /* 切换LED1 */
  STM_EVAL_LEDToggle(LED4);
}

/****************************************************************************
* 函数名: TIM3_IRQHandler()
* 功 能: 该函数可以处理TIM3全部中断请求
* 输 入: 无
* 输 出: 无
****************************************************************************/
void TIM3_IRQHandler(void)
{
  /* 清除TIM3更新中断 */
  TIM_ClearITPendingBit(TIM3, TIM_IT_Update);
  
  /* 切换LED2 */
  STM_EVAL_LEDToggle(LED3);
}

/****************************************************************************
* 函数名: TIM4_IRQHandler()
* 功 能: 该函数可以处理TIM4全部中断请求
* 输 入: 无
* 输 出: 无
****************************************************************************/
void TIM4_IRQHandler(void)
{
  /* 清除TIM4更新中断 */
  TIM_ClearITPendingBit(TIM4, TIM_IT_Update);
  
  /* 切换LED3 */
  STM_EVAL_LEDToggle(LED2);
}

/****** (C) 版权2012北京亿旗创新科技发展有限公司 ******文档结束*************/
